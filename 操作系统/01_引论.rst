1 引论
======

-  内核态：操作系统运行于其中。OS对硬件有完全访问权，可以执行机器能运行的所有指令。
-  用户态：应用程序运行与其中。只能执行机器指令的一个子集。

用户程序接口（shell或GUI界面）不属于操作系统内核，运行在用户态中。

1.1 什么是操作系统
------------------

操作系统的两大功能：

-  （向上）作为机器扩展（为应用程序和用户提供接口）
-  （向下）作为资源管理者

操作系统的资源管理主要用两种方式实现多路复用（共享）：

-  时间上复用：如CPU的轮转
-  空间上复用：如内存空间的使用

1.2 操作系统的历史
------------------

第一代：真空管和穿孔卡片
~~~~~~~~~~~~~~~~~~~~~~~~

这时还没有操作系统，程序员靠插拔电路和穿孔卡片来编程。

第二代：晶体管和批处理系统
~~~~~~~~~~~~~~~~~~~~~~~~~~

批处理系统（batch
system）：在输入室收集作业，用便宜的IBM1401把作业读到磁盘上，再用昂贵的IBM7094运行程序，输出再用IMB1401机器从磁盘打印。这时的输入输出是脱机（不与主机相连）进行的。

这时操作系统的代表有FMS（FORTRAN Monitor
System）和IBSYS（专门为IBM7094配备的操作系统）

第三代：集成电路和多道程序设计
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

60年代初计算机高低端两个代表：

-  IBM7094：用于工业强度的科学和工程计算。
-  IBM1041：用于商业计算。

IBM试图用System/360来尽可能满足两种需求。OS/360是对360机型的通用操作系统。这时操作系统的特点：

-  多道程序设计：7094会等IO，这对IO密集的商业计算来说很浪费。引入多道程序设计有效解决了这个问题。
-  同时的外部设备联机操作（Simultaneous Peripheral Operation On Line,
   SPOOLing）：不再需要IBM1041进行脱机IO了。

但这时的操作系统仍然是批处理的，程序员无法实时调试代码。为此出现了分时系统，每个用户都有一个联机终端。这类操作系统影响较大的是MULTICS，支持数百名分时用户（这种本地计算机处理界面，服务器进行计算的思想后来又以云计算的形式回归）。

随着小型机崛起，PDP机型的成功，参与MULTICS的Ken
Thompson在PDP-7上研发出来后来的UNIX。后来UNIX又出现了了很多版本。为了使程序能在任意版本的UNIX上运行，IEEE提出了POSIX标准。

第四代：个人计算机
~~~~~~~~~~~~~~~~~~

早期有CP/M(Control Program for
Microcomputer)和MS-DOS，这些系统都是基于命令行的。乔布斯设计了有GUI的苹果计算机。微软受影响开发了windows。早期windows只是运行在MS-DOS上的图形环境，直到windows
95才是一个独立的windows版本。

1.3 计算机硬件简介
------------------

要理解操作系统离不开对硬件的理解。这节只选择性记录。

处理器
~~~~~~

处理器中寄存器的类型：

-  通用寄存器：保存变量和临时结果
-  程序计数器：保存了将要取出的下一条指令的内存地址
-  堆栈指针：指向内存中当前栈的顶端
-  程序状态字（Program Status Word,
   PSW）寄存器：记录了CPU优先级、模式（用户态还是核心态）等信息。

多线程并不是真正的并行处理，在一个时刻只有一个进程在运行。（线程的切换速度很快，是纳秒级的）

GPU由成千上万的微内核组成，擅长处理大量并行的简单计算，但是很难编程。

存储器
~~~~~~

现代存储系统一般设计了两个缓存：

-  L1：在CPU中，通常同来将已解码的指令调入CPU中执行
-  L2：用来存放最近使用过的若干兆字节的内存字。

IO设备
~~~~~~

IO设备一般包括两个部分：设备控制器、设备本身

设备控制器的目的是给操作系统一个相对简单的接口。驱动程序专门与控制器对话。
