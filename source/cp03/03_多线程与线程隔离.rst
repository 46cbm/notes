3 多线程与线程隔离
==================

3.1 多线程
----------

多线程的一个例子

.. code:: python

   import threading
   import time

   def worker():
       t = threading.current_thread()
       time.sleep(2)
       print(t.getName() + 'leo 线程输出')

   new_t = threading.Thread(target=worker, name='leo thread')
   new_t.start()

   # 虽然新线程在上面就启动，但是主线程不会等待子线程把worker执行完，而是继续执行，输出下面这句话
   print('主线程输出')

输出

::

   主线程输出
   leo threadleo 线程输出

多线程可以更加充分的利用cpu的性能优势。如多核CPU让多个线程跑在多个核上面，实际上是并行执行。

3.2 全局解释器锁GIL
-------------------

但是python是没有办法利用多核CPU的优势。为了实现线程安全，有GIL，在解释器的层次上加了一个锁。

对于计算密集型，多线程确实没有多大意义。因为计算量没有被减少。但是对于IO密集型程序，主要时间都在等待返回结果，不需要占用CPU，所以python的多线程还是有意义的。

3.3 flask中的多线程
-------------------

请求的线程是由\ ``web server``\ 来发起的。flask自带的webserver默认是以单线程的方式来响应请求的，多个请求进来会排队。\ ``app.run(threaded=True)``\ 则会开启多线程模式。\ ``app.run(process=3,threaded=True)``\ 则是3个进程，多线程。

多线程存在的问题：

-  如果有多个请求，但是只有一个request变量名。如何区分request变量名指向的不同的Request对象。

解决方法：

-  用字典来实现线程隔离：键是线程的唯一表示，值是当前请求的Request对象。

::

   request = {thread_key1: Request1, thread_key2: Request2, ...}

flask使用werkzeug中的Local对象实现线程隔离，Local对象实际上就是用的字典来实现的。我们来看看使用Local对象的一个例子。

.. code:: python

   from werkzeug.local import Local
   import threading
   import time

   my_obj = Local()
   my_obj.b = 1

   def worker():
       my_obj.b = 2
       print('in new thread b is:' + str(my_obj.b))

   new_t = threading.Thread(target=worker)
   new_t.start()
   time.sleep(1)

   print('in main thread b is:' +  str(my_obj.b))

输出

::

   in new thread b is: 2
   in main thread b is: 1 # 如果不是Local对象的话这里是2

3.4 Local、LocalStack、字典
---------------------------

Local使用字典的方式实现线程隔离。LocalStack封装了Local对象，实现了一个线程隔离的栈结构。每个线程中的栈都是独立的。

.. code:: python

   from werkzeug.local import LocalStack
   import threading
   import time

   my_stack = LocalStack()
   my_stack.push(1)
   print('in main thread before push, value is: ' + str(my_stack.top))

   def worker():
       print('in new thread before push, value is: ' + str(my_stack.top))
       my_stack.push(2)
       print('in new thread after push, value is: ' + str(my_stack.top))

   new_t = threading.Thread(target=worker, name='leo_thread')
   new_t.start()

   time.sleep(1)
   print('finally, in main thread value is: ' + str(my_stack.top))

输出

::

   in main thread before push, value is: 1
   in new thread before push, value is: None
   in new thread after push, value is: 2
   finally, in main thread value is: 1

3.5 flask使用线程隔离的意义
---------------------------

使当前线程能正确引用到他自己创建的对象，而不是引用到其他线程所创建的对象。

.. code:: python

   class NonLocal:
       def __init__(self, v):
           self.v = v
   n = NonLocal(1)

   @web.route('/test')
   def test():
       print(n.v)
       n.v = 2
       print('------------')
       print(getattr(request, 'v', None))
       setattr(request, 'v', 2)
       print('------------')
       return ''

我们连续发两次请求，会输出

::

   1
   ------------
   None
   ------------
   127.0.0.1 - - [25/Jul/2019 22:57:11] "GET /test HTTP/1.1" 200 -
   2
   ------------
   None
   ------------
   127.0.0.1 - - [25/Jul/2019 22:57:12] "GET /test HTTP/1.1" 200 -

我们自己创建的对象n不是线程隔离的，所以不同的请求中n都是操作的同一个对象。但是request是线程隔离的，所以不会相互干扰。
