8 存储过程
==========

.. _存储过程-1:

8.1 存储过程
------------

概述
~~~~

存储过程是为以后的使用而保存的一条或多条MySQL语句的集合。可以看成函数或者批文件。

使用存储过程
~~~~~~~~~~~~

创建
''''

.. code:: sql

   CREATE PROCEDURE productpricing()
   BEGIN
       SELECT Avg(prod_price) AS priceaverage
       FROM products;
   END;

注意在命令行下\ ``;``\ 本身就是语句的分隔符，为了和存储过程内部的结尾分隔符区分开，可以自定义DELIMITER

.. code:: sql

   DELIMITER //
   CREATE PROCEDURE productpricing()
   BEGIN
       SELECT Avg(prod_price) AS priceaverage
       FROM products;
   END //
   DELIMITER ;

调用
''''

.. code:: sql

   mysql> CALL productpricing();
   +--------------+
   | priceaverage |
   +--------------+
   |    16.133571 |
   +--------------+

删除
''''

.. code:: sql

   DROP PROCEDURE productpricing;

注意删除不存在的存储过程会报错，如果不确定存不存在，可以用\ ``DROP PROCEDURE IF EXISTS``

指定参数
~~~~~~~~

在参数前可以加三个关键字

-  IN：传递给存储过程
-  OUT：从存储过程传到外面
-  INOUT：传入和传出

.. code:: sql

   DELIMITER //
   CREATE PROCEDURE productpricing(
       OUT pl DECIMAL(8, 2),
       OUT ph DECIMAL(8, 2),
       OUT pa DECIMAL(8, 2)
   )
   BEGIN
       SELECT Min(prod_price)
       INTO pl
       FROM products;
       SELECT Max(prod_price)
       INTO ph
       FROM products;
       SELECT Avg(prod_price)
       INTO pa
       FROM products;
   END //
   DELIMITER ;

调用并显示传除的参数

.. code:: sql

   mysql> CALL producpricing(
       ->     @pricelow,
       ->     @pricehigh,
       ->     @priceaverage
       -> );
   mysql> SELECT @priceaverage;
   +---------------+
   | @priceaverage |
   +---------------+
   |         16.13 |
   +---------------+

在看一个IN的例子，根据我们传入的订单号，显示那个订单的总价格

.. code:: sql

检查存储过程
~~~~~~~~~~~~

检查单个存储过程

.. code:: sql

   SHOW CREATE PROCEDURE procedure_name;

列出所有存储过程

.. code:: sql

   SHOW PROCEDURE STATUS;

8.2 游标
--------

使用游标，我们可以在检索出的行中进行前进或后退。不想大多数DBMS，MySQL的游标只能用于存储过程和函数。

.. code:: sql

   DELIMITER //
   CREATE PROCEDURE processorders()
   BEGIN
       -- Declare local variables
       DECLARE done BOOLEAN DEFAULT 0;
       DECLARE o INT;
       DECLARE t DECIMAL(8, 2);

       -- Declare the cursor
       DECLARE ordernumbers CURSOR
       FOR
       SELECT order_num FROM orders;

       -- Declare continue handler
       DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;

       -- Create a table to store the results
       CREATE TABLE IF NOT EXISTS ordertotals
           (order_num INT, total DECIMAL(8, 2));

       OPEN ordernumbers;

       REPEAT
           FETCH ordernumbers INTO o;
           CALL ordertotal(o, 1, t);

           INSERT INTO ordertotals(order_num, total)
           VALUES(o, t);
       UNTIL done END REPEAT;

       CLOSE ordernumbers;
   END //
   DELIMITER ;

``SQLSTATE '02000'``\ 是一个未找到的状态，也就是说游标没有指向数据后，会停止循环。

FETCH语句可以访问每一行，并且把游标向前移动一行。
