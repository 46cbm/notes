04 从c到cpp
===========

4.1 引用
--------

注意三点
~~~~~~~~

-  定义引用时一定要将其初始化成引用某个变量
-  初始化后，它就一直引用该变量，不会再引用别的变量（引用从一而终）
-  引用只能引用变量，不能引用常量和表达式

例子：用引用交换两个变量的值

.. code:: cpp

   void swap(int & a, int & b){
       int tmp;
       tmp = a; a = b; b = tmp;
   }
   int n1, n2;
   swap(n1, n2); // 交换n1和n2的值

引用作为函数的返回值

.. code:: cpp

   int n = 4;
   int & SetValue() {return n;}
   int main(){
       SetValue() = 40;  // 等价于把40赋值给全局变量n
       cout << n;        // 输出40
       return 0;
   }

常引用
~~~~~~

-  不能通过常引用去修改引用的内容

.. code:: cpp

   int n = 100;
   const int & r = n;
   r = 200; // 编译出错
   n = 300; // 没问题

常引用和非常引用的转换
~~~~~~~~~~~~~~~~~~~~~~

-  const T & 和T & 是不同的类型！！！
-  T &类型的引用可与用来初始化const T & 类型的引用
-  const T & 类型的引用和const T 类型的变量不能用来初始化T &
   类型的引用，除非进行强制类型转换。

4.2 const
---------

用法：

-  定义常量
-  定义常量指针
-  定义常引用

定义常量
~~~~~~~~

建议用\ ``const``\ 而不是\ ``define``\ 定义常量，因为\ ``const``\ 是有类型的，便于类型检查。

定义常量指针
~~~~~~~~~~~~

-  不能通过常量指针去修改指向的内容。但是指针本身还是可以指向其他地方。
-  不能把常量指针直接赋值给非常量指针，反过来可以。

函数参数为常量指针时，可避免函数内部不小心改变指针所指地方的内容。

4.3 动态内存分配
----------------

new
~~~

用new运算符实现动态内存分配

第一种用法，分配一个变量 ``P = new T``
T是任意类型名，P是类型为\ ``T *``\ 的指针。动态分配出一片大小为\ ``sizeof(T)``\ 字节的内存空间，并将该内存空间的起始地址赋值给P。

第二种用法，分配一个数组 ``P = new T[n]``
P是类型为\ ``T *``\ 的指针。n是要分配的数组元素的个数。动态分配出一片大小为\ ``n * sizeof(T)``\ 字节的内存空间，并将该内存空间的起始地址赋值给P。

``new T``\ 和\ ``new T[n]``\ 的返回值类型都是\ ``T *``

delete
~~~~~~

用\ ``new``\ 动态分配的内存空间，一定要用\ ``delete``\ 运算符进行释放
``delete 指针;`` //该指针必须指向new出来的空间。

回收动态数组： ``delete [] 指针;``

4.4 内联函数、函数重载、函数缺省参数
------------------------------------

内联函数
~~~~~~~~

为了减少函数调用的开销，引入了内联函数的机制。编译器处理对内联函数函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。在函数定义前加\ ``inline``\ 关键字，就可以定义内联函数。

函数重载
~~~~~~~~

名字相同，但是参数表不同（参数个数不同、或参数类型不同，注意返回值不能算）。重载不能有二意性，否则编译器会报错。

函数缺省参数
~~~~~~~~~~~~

缺省值只能在参数表的右边。
