7 面向对象（未完）
==================

7.1 实例对象与new
-----------------

典型的面向对象编程语言（比如 C++ 和
Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript
语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。

JavaScript
语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。

构造函数就是一个普通的函数，为了与普通函数区别，构造函数名字的第一个字母通常大写。构造函数的特点有两个。

-  函数体内部使用了this关键字，代表了所要生成的对象实例。
-  生成对象的时候，必须使用new命令。

new命令
~~~~~~~

new命令的作用，就是执行构造函数，返回一个实例对象。

.. code:: js

   var Vehicle = function (p) {
     this.price = p;
   };

   var v = new Vehicle(500);

new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。

.. code:: js

   // 推荐的写法
   var v = new Vehicle();
   // 不推荐的写法
   var v = new Vehicle;

如果调用构造函数时不加new，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。变量v变成了undefined，而price属性变成了全局变量。

.. code:: js

   var Vehicle = function (){
     this.price = 1000;
   };

   var v = Vehicle();
   v // undefined
   price // 1000

构造函数内部使用严格模式，即第一行加上use
strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。严格模式中，函数内部的this不能指向全局对象，默认等于undefined。

.. code:: js

   function Fubar(foo, bar){
     'use strict';
     this._foo = foo;
     this._bar = bar;
   }

   Fubar()
   // TypeError: Cannot set property '_foo' of undefined

new 命令的原理
~~~~~~~~~~~~~~

使用new命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的prototype属性。
3. 将这个空对象赋值给函数内部的this关键字。
4. 开始执行构造函数内部的代码。

如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。

.. code:: js

   var Vehicle = function () {
     this.price = 1000;
     return 1000;
   };

   (new Vehicle()) === 1000
   // false

但如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。

.. code:: js

   var Vehicle = function (){
     this.price = 1000;
     return { price: 2000 };
   };

   (new Vehicle()).price
   // 2000

另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。

.. code:: js

   function getMessage() {
     return 'this is a message';
   }

   var msg = new getMessage();

   msg // {}
   typeof msg // "object"

new.target属性
~~~~~~~~~~~~~~

函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。

.. code:: js

   function f() {
     console.log(new.target === f);
   }

   f() // false
   new f() // true

.. code:: js

   function f() {
     if (!new.target) {
       throw new Error('请使用 new 命令调用！');
     }
     // ...
   }

   f() // Uncaught Error: 请使用 new 命令调用！

Object.create() 创建实例对象
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在拿不到构造函数，但是有对象实例的情况下，可以使用对象.create()来创建一个新的对象。下面的例子中，对象person1是person2的模板，后者继承了前者的属性和方法。

.. code:: js

   var person1 = {
     name: '张三',
     age: 38,
     greeting: function() {
       console.log('Hi! I\'m ' + this.name + '.');
     }
   };

   var person2 = Object.create(person1);

   person2.name // 张三
   person2.greeting() // Hi! I'm 张三.

7.2 this关键字
--------------

this的含义
~~~~~~~~~~

this总返回一个对象。this就是属性或方法“当前”所在的对象。

this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，this就是当前describe方法所在的对象。

.. code:: js

   function f() {
     return '姓名：'+ this.name;
   }

   var A = {
     name: '张三',
     describe: f
   };

   var B = {
     name: '李四',
     describe: f
   };

   A.describe() // "姓名：张三"
   B.describe() // "姓名：李四"

下面的例子是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此this就代表传入当前对象（即文本框），然后就可以从this.value上面读到用户的输入值。

.. code:: html

   <input type="text" name="age" size=3 onChange="validate(this, 18, 99);">

   <script>
   function validate(obj, lowval, hival){
     if ((obj.value < lowval) || (obj.value > hival))
       console.log('Invalid Value!');
   }
   </script>

总结一下，JavaScript
语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是
JavaScript
支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。

this的实质
~~~~~~~~~~

我们先来看看js中内存的数据结构。

下面的代码JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5
}，然后把这个对象的内存地址赋值给变量obj。变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。

.. code:: js

   var obj = { foo:  5 };

原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。上面例子的foo属性，实际上是以下面的形式保存的。

.. code:: js

   {
     foo: {
       [[value]]: 5
       [[writable]]: true
       [[enumerable]]: true
       [[configurable]]: true
     }
   }

如果foo的值是函数的话，则保存的是函数的地址

.. code:: js

   {
     foo: {
       [[value]]: 函数的地址
       ...
     }
   }

由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。JavaScript
允许在函数体内部，引用当前环境的其他变量。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

.. code:: js

   var f = function () {
     console.log(this.x);
   }

   var x = 1;
   var obj = {
     f: f,
     x: 2,
   };

   // 单独执行
   f() // 1

   // obj 环境执行
   obj.f() // 2
